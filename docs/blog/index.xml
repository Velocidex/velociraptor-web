<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Velociraptor Blog on Velociraptor / Dig deeper</title>
    <link>/blog/</link>
    <description>Recent content in Velociraptor Blog on Velociraptor / Dig deeper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Nov 2020 00:38:44 +0000</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Browsing around the filesystem.</title>
      <link>/blog/html/2018/08/10/browsing_around_the_filesystem.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/browsing_around_the_filesystem.html</guid>
      <description>The Virtual File System Like GRR, Velociraptor also maintains a virtual file system view (VFS) of the client&#39;s filesystem. GRR&#39;s VFS view is generated by adding a row for each file into the database. In order to refresh the view of a certain directory, GRR issues a ListDirectory request and updates the database by storing each newly discovered file in its own row.
Velociraptor models the client&#39;s VFS as a per-directory VQL query.</description>
    </item>
    
    <item>
      <title>The Windows USN Journal</title>
      <link>/blog/medium/2020-11-13-the-windows-usn-journal-f0c55c9010e/</link>
      <pubDate>Thu, 12 Nov 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-11-13-the-windows-usn-journal-f0c55c9010e/</guid>
      <description>Thanks to Matt Green for discussions, ideas and code….
NTFS is the default filesystem on Windows systems, so it is important for DFIR tools to support extracting as much system state information as possible from it. Velociraptor already has a full featured NTFS parser, and in a recent release (0.5.2) also added a parser for the USN Journal (Update Sequence Number Journal), or Change Journal.
What is the USN Journal? By default Windows maintains a journal of filesystem activities is a file called $Extend$UsnJrnl in a special data stream called** $J**.</description>
    </item>
    
    <item>
      <title>Velociraptor Communications</title>
      <link>/blog/medium/2020-09-28-velociraptor-network-communications-30568624043a/</link>
      <pubDate>Sun, 27 Sep 2020 01:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-09-28-velociraptor-network-communications-30568624043a/</guid>
      <description>You might have heard that Velociraptor allows you to quickly query endpoint state for rapid response and monitoring of many thousands of devices across the internet. Unlike some other tools, Velociraptor’s communication is scalable, secure and instantaneous.
Many people ask me about the client/server communication protocol. The Velociraptor documentation simply states that communications is encrypted over a TLS connection but there is more to it than that.
In this post I would like to delve into the low level details of how clients securely communicate with the server and cover some common deployment scenarios.</description>
    </item>
    
    <item>
      <title>Velociraptor SSO Authentication</title>
      <link>/blog/medium/2020-08-17-velociraptor-sso-authentication-6dd68d46dccf/</link>
      <pubDate>Sun, 16 Aug 2020 01:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-08-17-velociraptor-sso-authentication-6dd68d46dccf/</guid>
      <description>The Velociraptor GUI allows administrators and DFIR team members to rapidly respond and hunt across their entire deployment in seconds. This is a powerful capability, and must be adequately protected.
Modes of authentication Velociraptor supports two modes of authentication:
  Basic authentication
  Single Sign On using third party OAuth2 logon flow.
  In the basic authentication mode, GUI users are added by the administrator and given passwords.</description>
    </item>
    
    <item>
      <title>Profiling the beast</title>
      <link>/blog/medium/2020-08-16-profiling-the-beast-58913437fd16/</link>
      <pubDate>Sun, 16 Aug 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-08-16-profiling-the-beast-58913437fd16/</guid>
      <description>Photo by Daniel Cheung on Unsplash
You might have previously heard about Velociraptor — fast becoming the standard open source agent for endpoint monitoring and collection. Being an open source project provides users with visibility into the inner workings of the tool since anyone can see the source code and even contribute to it!
While I usually write about Velociraptor features that make DFIR work easier and more effective, this time I am actually going to talk about a feature of the Golang programming language itself (which Velociraptor is written in).</description>
    </item>
    
    <item>
      <title>Triage with Velociraptor — Pt 4</title>
      <link>/blog/medium/2020-07-14-triage-with-velociraptor-pt-4-cf0e60810d1e/</link>
      <pubDate>Tue, 14 Jul 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-07-14-triage-with-velociraptor-pt-4-cf0e60810d1e/</guid>
      <description>Woman vector created by vectorpouch — www.freepik.com
Velociraptor is a great tool for collecting Artifacts such as files and other state information from endpoints. Artifacts are simply VQL queries wrapped inside a YAML file providing the query with sufficient context to operate. Typically the triage phase of the DFIR process involves collecting and preserving evidence as quickly as possible, performing quick analysis in order to identify machines of interest for further analysis.</description>
    </item>
    
    <item>
      <title>Velociraptor in the tool age</title>
      <link>/blog/medium/2020-07-13-velociraptor-in-the-tool-age-d896dfe71b9/</link>
      <pubDate>Mon, 13 Jul 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-07-13-velociraptor-in-the-tool-age-d896dfe71b9/</guid>
      <description>People vector created by brgfx — www.freepik.com
Velociraptor is a powerful endpoint visibility tool. It has plugins and parsers for many file formats, such as raw NTFS access, raw registry hive, prefetch files etc.
However, as most DFIR professionals know, there are so many tools out there that we would love to use in our IR work. One of the strengths of Velociraptor is its flexibility afforded by the use of theVelociraptor Query Language (VQL).</description>
    </item>
    
    <item>
      <title>The Velociraptor Query Language Pt 2</title>
      <link>/blog/medium/2020-06-19-the-velociraptor-query-language-pt-2-fe92bb7aa150/</link>
      <pubDate>Fri, 19 Jun 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-06-19-the-velociraptor-query-language-pt-2-fe92bb7aa150/</guid>
      <description>In our previous article I introduced the basics of the Velociraptor Query Language (VQL). We have learned the basic structure of VQL is similar to the SQL SELECT statement
However, one of the main differences between SQL and VQL is that VQL’s data sources are not simple data tables, but are instead executable code termed “plugins”. VQL plugins are simply generators of rows, and may take a number of named arguments.</description>
    </item>
    
    <item>
      <title>The Velociraptor Query Language Pt 1</title>
      <link>/blog/medium/2020-06-14-the-velociraptor-query-language-pt-1-d721bff100bf/</link>
      <pubDate>Sun, 14 Jun 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-06-14-the-velociraptor-query-language-pt-1-d721bff100bf/</guid>
      <description>Velociraptor’s query language is central to the operation of Velociraptor. We find it being used in querying endpoints, collecting forensic artifacts and endpoint state and even in post processing data on the server.
 Velociraptor is ultimately just a VQL query evaluation engine!  Why should you know more about VQL? Users do not actually need to know VQL to simply collect DFIR artifacts from endpoints, hunt for malware or remediate an infection.</description>
    </item>
    
    <item>
      <title>Velociraptor</title>
      <link>/blog/medium/2020-04-16-velociraptor-e48a47e0317d/</link>
      <pubDate>Thu, 16 Apr 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-04-16-velociraptor-e48a47e0317d/</guid>
      <description>This is an introductory article explaining the rationale behind Velociraptor’s design and particularly how Velociraptor evolved with some historical context compared with other DFIR tooling. We took a lot of inspiration and learned many lessons by using other great tools, and Velociraptor is our attempt at pushing the field forward.
Digital forensics is primarily focused on answering questions. Most practitioners limit their cases around high level questions, such as did the user access a particular file?</description>
    </item>
    
    <item>
      <title>Velociraptor’s ACL model</title>
      <link>/blog/medium/2020-03-29-velociraptors-acl-model-7f497575daee/</link>
      <pubDate>Sun, 29 Mar 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-03-29-velociraptors-acl-model-7f497575daee/</guid>
      <description>Photo by Jose Fontano on Unsplash
Velociraptor is a very powerful tool with a great deal of privileged access to many endpoints. Velociraptor clients typically run with System or root level access on endpoints, in order to have low level access to the operating system. It follows that administrators on Velociraptor also have privileged access to the entire domain as well — they are equivalent to domain administrators.
For small trusted teams of investigators this is probably fine, however as Velociraptor is being more widely deployed in enterprise environments it has become clear that we needed a more elaborate role based ACL model.</description>
    </item>
    
    <item>
      <title>Velociraptor notebooks</title>
      <link>/blog/medium/2020-03-28-velociraptor-notebooks-d02e0bd11230/</link>
      <pubDate>Sat, 28 Mar 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-03-28-velociraptor-notebooks-d02e0bd11230/</guid>
      <description>Velociraptor is a great tool for collecting endpoint state easily and efficiently. It is so efficient, that sometimes we end up with a lot of collected data and are left with the task of making sense of the data, and documenting our investigative process.
In a previous article we have seen how post-processing of collected data can be done using Jupyter notebooks. The notebook is a living document, allowing us to run analysis code interspersed among documentation which can be updates in real time, as the analyst post-processes and annotates the data.</description>
    </item>
    
    <item>
      <title>Extending VQL plugins</title>
      <link>/blog/medium/2020-03-07-extending-vql-plugins-7fb004cb6ec4/</link>
      <pubDate>Sat, 07 Mar 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-03-07-extending-vql-plugins-7fb004cb6ec4/</guid>
      <description>Velociraptor is a unique endpoint visibility tool because it provides the ability for users to write custom, tailored queries using the Velociraptor Query Language (VQL). Having a powerful query language right at the endpoint gives our responders unprecedented flexibility, and the ability to leverage the experience of other analysts within the vibrant Velociraptor community.
VQL is a powerful language but was never designed to be a full featured programming language — it is deliberately kept simple and easy to use.</description>
    </item>
    
    <item>
      <title>Velociraptor Post-processing with Jupyter Notebook and Pandas</title>
      <link>/blog/medium/2020-03-06-velociraptor-post-processing-with-jupyter-notebook-and-pandas-8a344d05ee8c/</link>
      <pubDate>Fri, 06 Mar 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-03-06-velociraptor-post-processing-with-jupyter-notebook-and-pandas-8a344d05ee8c/</guid>
      <description>Velociraptor is a powerful endpoint visibility tool. The unique strength of the tool is being able to collect endpoint state by using the Velociraptor Query Language (VQL) via custom or curated “Artifacts”. Not only can one collect artifacts from a single host, but one can collect the same artifact from many thousands of hosts within seconds.
Being able to collect a lot of data quickly is awesome, but the flip side is that a lot of data makes it harder to review manually.</description>
    </item>
    
    <item>
      <title>Hunting Malware using Mutants</title>
      <link>/blog/medium/2020-01-12_hunting-malware-using-mutants-ea08e86dfc19/</link>
      <pubDate>Sun, 12 Jan 2020 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2020-01-12_hunting-malware-using-mutants-ea08e86dfc19/</guid>
      <description>By Mike Cohen Recently Velociraptor has gained some interesting process analysis features. This is the first in a series of short articles discussing how you can use these new features to inspect suspicious processes on your endpoint and hopefully catch malware before it can gain a long term foothold.
This article will focus on windows Named Mutex Objects (On windows these are called Mutant Objects for some reason).
Mutants and Malware What is a Mutant?</description>
    </item>
    
    <item>
      <title>Digging into the System Resource Usage Monitor (SRUM)</title>
      <link>/blog/medium/2019-12-31_digging-into-the-system-resource-usage-monitor-srum-afbadb1a375/</link>
      <pubDate>Tue, 31 Dec 2019 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2019-12-31_digging-into-the-system-resource-usage-monitor-srum-afbadb1a375/</guid>
      <description>Uncovering history with Velociraptor By Mike Cohen Commonly in many incident response scenarios we need to gather evidence of program executions. For example, a phishing email delivering malware was sent to a user — did the user click on it? Did the malware run? was the email forwarded to any other users?
One of the most useful sources of evidence of execution on Windows is the System Resource Usage Monitor (SRUM).</description>
    </item>
    
    <item>
      <title>Velociraptor to Elasticsearch</title>
      <link>/blog/medium/2019-12-08-velociraptor-to-elasticsearch-3a9fc02c6568/</link>
      <pubDate>Sun, 08 Dec 2019 23:50:52 +0000</pubDate>
      
      <guid>/blog/medium/2019-12-08-velociraptor-to-elasticsearch-3a9fc02c6568/</guid>
      <description>Taking your data elsewhere… By Justin Welgemoed Since release 0.3.5 Velociraptor includes an Elastic VQL plugin plus two built-in server artifacts that demonstrate how to make use of this plugin.
Set your data free! Velociraptor is great at collecting oceans of information from a vast fleet of client machines but that information is, by default, only stored locally on the Velociraptor server.
In a typical deployment, responders and analysts tend to either…</description>
    </item>
    
    <item>
      <title>Recovering deleted NTFS Files with Velociraptor</title>
      <link>/blog/medium/2019-11-15_recovering-deleted-ntfs-files-with-velociraptor-1fcf09855311/</link>
      <pubDate>Fri, 15 Nov 2019 00:38:44 +0000</pubDate>
      
      <guid>/blog/medium/2019-11-15_recovering-deleted-ntfs-files-with-velociraptor-1fcf09855311/</guid>
      <description>By Mike Cohen On a recent engagement we responded to an intrusion where the attacker has added a new scheduled task to the Windows Task Scheduler directory (%systemroot%\System32\Task) some time ago. This is a common TTP for achieving persistence (See Mitre Att&amp;amp;ck). Unfortunately the actual task file was later removed and event logs were cycled past the time of interest.
In that case we were able to use Velociraptor to employ some deep forensic techniques and with a bit of luck were able to recover the deleted task file.</description>
    </item>
    
    <item>
      <title>Windows Event Logs</title>
      <link>/blog/medium/2019-11-12_windows-event-logs-d8d8e615c9ca/</link>
      <pubDate>Tue, 12 Nov 2019 10:40:24 +0000</pubDate>
      
      <guid>/blog/medium/2019-11-12_windows-event-logs-d8d8e615c9ca/</guid>
      <description>By Mike Cohen One of the most critical sources of data when responding to an incident on windows systems is the event logs. Windows event logs record security significant events.
However, unlike more traditional Unix syslogs, the Windows Event Log system is more complex and there are a number of potential problems that an investigator can run into.
In this post we explore the windows event log system from the point of view of the investigator.</description>
    </item>
    
    <item>
      <title>Triage with Velociraptor — Pt 3</title>
      <link>/blog/medium/2019-10-08_triage-with-velociraptor-pt-3-d6f63215f579/</link>
      <pubDate>Tue, 08 Oct 2019 09:03:34 +0000</pubDate>
      
      <guid>/blog/medium/2019-10-08_triage-with-velociraptor-pt-3-d6f63215f579/</guid>
      <description>By Mike Cohen This is the final part of this three part series of articles describing how to use Velociraptor to collect files from an endpoint. Our first part shows how we can use the Velociraptor agent in a typical client/server setting to collect artifacts from one or many endpoints at the push of a button, within seconds.
Part two examined what to do if Velociraptor is not already installed as an agent (or can not be remotely installed).</description>
    </item>
    
    <item>
      <title>Triage with Velociraptor — Pt 2</title>
      <link>/blog/medium/2019-10-04_triage-with-velociraptor-pt-2-d0f79066ca0e/</link>
      <pubDate>Fri, 04 Oct 2019 23:50:52 +0000</pubDate>
      
      <guid>/blog/medium/2019-10-04_triage-with-velociraptor-pt-2-d0f79066ca0e/</guid>
      <description>By Mike Cohen In the previous part of this series of articles we saw how Velociraptor can be used to automatically collect and preserve files from a remote system. This is great if you have Velociraptor installed as an agent on the endpoint — but what if you (or your customer) does not?
Interactive collection Velociraptor is essentially a query engine. All its operations are controlled by VQL queries normally encapsulated in a YAML files called artifacts.</description>
    </item>
    
    <item>
      <title>Triage with Velociraptor — Pt 1</title>
      <link>/blog/medium/2019-10-02_triage-with-velociraptor-pt-1-253f57ce96c0/</link>
      <pubDate>Wed, 02 Oct 2019 13:32:39 +0000</pubDate>
      
      <guid>/blog/medium/2019-10-02_triage-with-velociraptor-pt-1-253f57ce96c0/</guid>
      <description>By Mike Cohen This is part 1 of the 3 part series focused around triaging and file collection.
Traditionally digital forensic practitioners and incident responders collected disk images to retain evidence in cases of compromise. However in recent times, the size of investigations and the short time frames required, started a trend of more selective evidence collection. Instead of collecting the entire disk, responders now prefer to collect only critical files allowing more rapid triage.</description>
    </item>
    
    <item>
      <title>Velociraptor’s client side buffer</title>
      <link>/blog/medium/2019-09-11_velociraptor-s-client-side-buffer-3ce03697a4e6/</link>
      <pubDate>Wed, 11 Sep 2019 00:31:39 +0000</pubDate>
      
      <guid>/blog/medium/2019-09-11_velociraptor-s-client-side-buffer-3ce03697a4e6/</guid>
      <description>By Mike Cohen The recent Velociraptor release (0.3.3) features a client side buffer. What does this do and how does it change Velociraptor’s approach to incident response?
What is a local buffer? The Velociraptor client is really just a (Velociraptor Query Language) VQL execution engine. When collecting an artifact, the client running on the endpoint, simply executes the VQL and streams rows from the query to the server as they occur.</description>
    </item>
    
    <item>
      <title>The Velociraptor API and FUSE</title>
      <link>/blog/html/2019/08/28/the_velociraptor_api/</link>
      <pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/html/2019/08/28/the_velociraptor_api/</guid>
      <description>The Velociraptor GUI is very useful, but for the power user, the Velociraptor API provides a powerful mechanism to integrate and automate. We previously discussed how the Velociraptor API can be used by external programs. This post explore a sample program that uses the API and presents a client&amp;rsquo;s VFS as a FUSE directory.
This allows us to navigate the remote end point&amp;rsquo;s file system as if it was mounted locally - we can list directories or fetch files, or even open remote files using third party programs.</description>
    </item>
    
    <item>
      <title>Agentless hunting with Velociraptor</title>
      <link>/blog/html/2019/03/02/agentless_hunting_with_velociraptor.html</link>
      <pubDate>Sat, 02 Mar 2019 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2019/03/02/agentless_hunting_with_velociraptor.html</guid>
      <description>There has been a lot of interest lately in Agentless hunting especially using PowerShell. There are many reasons why Agentless hunting is appealing - there are already a ton of endpoint agents and yet another one may not be welcome. Somtimes we need to deploy endpoint agents as part of a DFIR engagement and we may not want to permanently install yet another agent on end points.
This blog post explores an agentless deployment scenario, where we do not want to install Velociraptor permanently on the end point, but rather push it to end points temporarily to collect specific artifacts.</description>
    </item>
    
    <item>
      <title>Alerting on event patterns</title>
      <link>/blog/html/2019/02/14/alerting_on_event_patterns.html</link>
      <pubDate>Thu, 14 Feb 2019 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2019/02/14/alerting_on_event_patterns.html</guid>
      <description>We have shown in earlier posts how Velociraptor uses VQL to define event queries that can detect specific conditions. These conditions can be used to create alerts and escalation actions.
One of the most useful types of alerts is detecting a pattern of activity. For example we can detect failed and successful login attempts seperately, but it is the specific pattern of events (say 5 failed login attempts followed by a successful one) that is interesting from a detection point of view.</description>
    </item>
    
    <item>
      <title>Velociraptor Performance</title>
      <link>/blog/html/2019/02/10/velociraptor_performance.html</link>
      <pubDate>Sun, 10 Feb 2019 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2019/02/10/velociraptor_performance.html</guid>
      <description>We are often asked how many resources does a Velociraptor deployment use? How should one spec a machine for a Velociraptor deployment?
We have previously said that one of the reasons we developed Velociraptor was to improve on the performance of GRR which was not scalable for our use case.
We&#39;ve been working with the team at Klein &amp;amp; Co. on several intrusions over the past several months, which are providing valuable opportunities to deploy and test Velociraptor in a range of real world investigation scenarios.</description>
    </item>
    
    <item>
      <title>The Velociraptor Python API</title>
      <link>/blog/html/2019/02/09/velociraptor_python_api.html</link>
      <pubDate>Sat, 09 Feb 2019 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2019/02/09/velociraptor_python_api.html</guid>
      <description>Velociraptor is very good at collecting artifacts from endpoints. However, in modern DFIR work, the actual collection is only the first step of a much more involved process. Typically we want to post process data using more advanced data mining tools (such as data stacking). Velociraptor usually is only a part of a wider solution which might include a SIEM and SOC integration.
In order to facilitate interoperability with other tools, Velociraptor now offers an external API.</description>
    </item>
    
    <item>
      <title>Velociraptor&#39;s client communications</title>
      <link>/blog/html/2018/09/03/velociraptor_s_client_communications.html</link>
      <pubDate>Sat, 09 Feb 2019 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/09/03/velociraptor_s_client_communications.html</guid>
      <description>How does the GRR client communicate? The GRR client protocol is depicted below.
Due to network realities such as NAT, firewalls etc, it is not possible to directly connect to the client, so GRR relies on the client connecting to the server in order to communicate with it.
The GRR client makes periodic POST requests to the server to both send replies and receive new instructions. Since POST requests are very short lived (most client polls carry no data) the client has to repeat the polls periodically.</description>
    </item>
    
    <item>
      <title>Deploying Velociraptor with OAuth SSO</title>
      <link>/blog/html/2018/12/23/deploying_velociraptor_with_oauth_sso.html</link>
      <pubDate>Sun, 23 Dec 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/12/23/deploying_velociraptor_with_oauth_sso.html</guid>
      <description>In the previous post we saw how to set up Velociraptor&#39;s GUI over SSL. This is great, but we still need to create users and assign them passwords manually. The trouble with user account management is that we can not enforce 2 factor authentication, or any password policies or any of the usual enterprise requirements for user account management. It is also difficult for users to remember yet another password for a separate system, and so might make the password easily guessable.</description>
    </item>
    
    <item>
      <title>Configuring Velociraptor for SSL</title>
      <link>/blog/html/2018/12/22/configuring_velociraptor_for_ssl.html</link>
      <pubDate>Sat, 22 Dec 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/12/22/configuring_velociraptor_for_ssl.html</guid>
      <description>We have previously seen how to deploy a new Velociraptor server. For a simple deployment we can have Velociraptor server and clients provisioned in minutes.
Usually we deploy a specific Velociraptor deployment on our DFIR engagements. We use cloud resources to provision the server and have the clients connect to this cloud VM. A proper secure deployment of Velociraptor will use SSL for securing both client communication and protecting the web GUI.</description>
    </item>
    
    <item>
      <title>Velociraptor Interactive Shell</title>
      <link>/blog/html/2018/12/11/velociraptor_interactive_shell.html</link>
      <pubDate>Tue, 11 Dec 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/12/11/velociraptor_interactive_shell.html</guid>
      <description>One of the interesting new features in the latest release of Velociraptor is an interactive shell. One can interact with the end point over the standard Velociraptor communication mechanism - an encrypted and authenticated channel.
This feature is implemented by utilizing the Velociraptor event monitoring, server side VQL queries. This post explores how these components come together to deliver a responsive, interactive workflow.
Endpoint shell access Although we generally try to avoid it, sometimes the easiest way to extract certain information is to run a command and parse its output.</description>
    </item>
    
    <item>
      <title>Server side VQL queries and Escalation Events</title>
      <link>/blog/html/2018/12/10/server_side_vql_queries_and_events.html</link>
      <pubDate>Mon, 10 Dec 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/12/10/server_side_vql_queries_and_events.html</guid>
      <description>Previously we have seen how Velociraptor collects information from end points using Velociraptor artifacts. These artifacts encapsulate user created queries using the Velociraptor Query Language (VQL). The power of VQL is that it provides for a very flexible way of specifying exactly what should be collected from the client and how - without needing to modify client code or deploy new clients!
This is not the whole story though! It is also possible to run VQL queries on the server side!</description>
    </item>
    
    <item>
      <title>More on client event collection</title>
      <link>/blog/html/2018/12/09/more_on_client_event_collection.html</link>
      <pubDate>Sun, 09 Dec 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/12/09/more_on_client_event_collection.html</guid>
      <description>Periodic Event queries The simplest kind of events are periodically generated events. These are created using the clock() VQL plugin. This is a simple event plugin which just emits a new row periodically.
$ velociraptor query &amp;quot;select Unix from clock(period=5)&amp;quot; --max_wait 1 [ { &amp;quot;Unix&amp;quot;: 1544339715 } ][ { &amp;quot;Unix&amp;quot;: 1544339720 } ]^C The query will never terminate, instead the clock() plugin will emit a new timestamp every 5 seconds. Note the --max_wait flag which tells Velociraptor to wait at least for 1 second in order to batch rows before reporting them.</description>
    </item>
    
    <item>
      <title>Velociraptor training at NZITF</title>
      <link>/blog/html/2018/11/13/velociraptor_training_at_nzitf.html</link>
      <pubDate>Tue, 13 Nov 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/11/13/velociraptor_training_at_nzitf.html</guid>
      <description>Velociraptor training at NZITF We are very excited to run this full day training workshop at the New Zealand Internet Engineering Task Force (NZITF) conference.
The training material can be downloaded here &amp;quot;Velociraptor NZITF training&amp;quot;.</description>
    </item>
    
    <item>
      <title>Event Queries and Endpoint Monitoring</title>
      <link>/blog/html/2018/11/09/event_queries_and_endpoint_monitoring.html</link>
      <pubDate>Fri, 09 Nov 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/11/09/event_queries_and_endpoint_monitoring.html</guid>
      <description>Why monitor endpoint events? Recording end point event information on the server gives a bunch of advantages. For one, the server keeps a record of historical events, which makes going back to search for these easy as part of an incident response activity.
For example, Velociraptor can keep a running log of process execution events for all clients, on the server. If a particular executable is suspected to be malicious, we can now go back and search for the execution of that process in the past on the infected machine (for establishing the time of infection), as well as search the entire deployment base for the same binary execution to be able identify lateral movement and wider compromises.</description>
    </item>
    
    <item>
      <title>Velorciraptor&#39;s filesystem&#39;s accessors</title>
      <link>/blog/html/2018/09/30/velorciraptor_s_filesystem_s_accessors.html</link>
      <pubDate>Sun, 30 Sep 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/09/30/velorciraptor_s_filesystem_s_accessors.html</guid>
      <description>In addition, Velociraptor can now also read Volume Shadow Copy snapshots. The gives a kind of time-machine ability to allow the investigator to look through the drive content at a previous point in the past.
This blog post introduces the new features and describe how Velociraptor&#39;s filesystem accessors work to provide data from multiple sources to VQL queries.
We have previously seen that Velociraptor can list and download files from the client&#39;s filesystem, as well as registry keys and values.</description>
    </item>
    
    <item>
      <title>Detecting powershell persistence with Velociraptor and Yara</title>
      <link>/blog/html/2018/09/29/detecting_powershell_persistence_with_velociraptor_and_yara.html</link>
      <pubDate>Sat, 29 Sep 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/09/29/detecting_powershell_persistence_with_velociraptor_and_yara.html</guid>
      <description>::: {.admonition} Update
As of the latest release of Velociraptor we have raw registry parsing which can also be done via raw NTFS to get around file locking. It is no longer necessary to run yara scans and parse with regripper as shown here. :::
I was watching the SANS DFIR Summit 2018 videos on youtube and came across Mari DeGrazia&#39;s talk titled &amp;quot;Finding and Decoding Malicious Powershell Scripts&amp;quot;. This is an excellent talk and it really contains a wealth of information.</description>
    </item>
    
    <item>
      <title>Velociraptor walk through and demo</title>
      <link>/blog/html/2018/09/03/velociraptor_walk_through_and_demo.html</link>
      <pubDate>Mon, 03 Sep 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/09/03/velociraptor_walk_through_and_demo.html</guid>
      <description>I just uploaded a screencast of the latest Velociraptor - check it out and play with it, and please provide feedback at velociraptor-discuss@googlegroups.com
  </description>
    </item>
    
    <item>
      <title>Velociraptor Artifacts</title>
      <link>/blog/html/2018/08/20/velociraptor_artifacts.html</link>
      <pubDate>Mon, 20 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/20/velociraptor_artifacts.html</guid>
      <description>First a bit of history. When we first started writing endpoint monitoring tools (With GRR then Rekall Agent) we implemented the ability to collect files, registry keys and other data. If an analyst wanted to collect, say the chrome extensions, they would need to know where chrome extensions typically reside ( %homedir%/.config/google-chrome/Extensions/**) and enter that in each time.
We soon realized this was error prone and required too much mental overhead for analysts to constantly remember these details.</description>
    </item>
    
    <item>
      <title>Design differences between Velociraptor and GRR</title>
      <link>/blog/html/2018/08/10/design_differences_between_velociraptor_and_grr.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/design_differences_between_velociraptor_and_grr.html</guid>
      <description>Velociraptor Clients run full VQL queries GRR&#39;s design started off with the assumption that the client should be minimalist and only support a few simple primitives (such as ListDirectory, ListProcesses etc). The intention was that most of the processing would be executed on the server inside a &amp;quot;Flow&amp;quot;. The main motivation for this design choice was the observation that it is difficult to upgrade the client in practice, and so with a minimal client, it would be possible to develop more sophisticated Flows, server side, without needing to update the clients.</description>
    </item>
    
    <item>
      <title>Files, files everything is just a file!</title>
      <link>/blog/html/2018/02/09/files_files_everything_is_just_a_file.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/02/09/files_files_everything_is_just_a_file.html</guid>
      <description>GRR&#39;s original design abstracted the data storage to a simple key/value store originally based around Bigtable. For open source deployments various key value stores were used starting from MongoDB, to SQLite and finally MySQL. Although the original idea was to use a simple key/value implementation, due to locking requirements the data store implementation became very complex.
As Velociraptor introduced a major redesign of the underlying data store architecture, we are now able to relax our demands of the datastore and use a true key/value model (since we have no requirements for locking and synchronization).</description>
    </item>
    
    <item>
      <title>Hunting - What Velociraptors do best!</title>
      <link>/blog/html/2018/08/10/hunting_what_velociraptors_do_best.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/hunting_what_velociraptors_do_best.html</guid>
      <description>Velociraptor has completely redesigned the way that hunts are implemented in order to avoid database locking and increase hunt processing efficiency.
Now we hunt like this:
{.align-center}
How are hunts scheduled? GRR allows hunts to be scheduled by a few client properties such as OS type, label, users etc. This works because GRR has an extensive data model of endpoint properties. However, this requires that the data model be refreshed periodically to be kept accurate.</description>
    </item>
    
    <item>
      <title>Interrogation - Make the endpoint tell us what it knows!</title>
      <link>/blog/html/2018/08/10/interrogation_make_the_endpoint_tell_us_what_it_knows.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/interrogation_make_the_endpoint_tell_us_what_it_knows.html</guid>
      <description>When writing Velociraptor we decided to keep things very simple - we did away with a lot of the information gathered during interrogate in favor of a much simpler data model.
Data Modelling - The Interrogate Flow GRR maintains an elaborate model of client data. For example, GRR collects and maintains a list of clients&#39; network interfaces, users, user&#39;s home directory etc. This information is maintained in elaborate protobufs and stored in the database in many rows.</description>
    </item>
    
    <item>
      <title>Velocidex Query Language (VQL)</title>
      <link>/blog/html/2018/08/10/the_velocidex_query_language.html</link>
      <pubDate>Fri, 10 Aug 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/the_velocidex_query_language.html</guid>
      <description>VQL Overview VQL is only loosely based around SQL in the sense that the general statement structure is similar. However, VQL is a very simple dialect. Like SQL, a VQL query produces a table of results with specific columns and multiple rows. Unlike SQL, the data inside each cell is not limited to simple primitive types (like string, integer etc). In fact any JSON serializable object can be generated in a table&#39;s cell.</description>
    </item>
    
    <item>
      <title>Introducing Velociraptor</title>
      <link>/blog/html/2018/08/10/introducing_velociraptor.html</link>
      <pubDate>Fri, 09 Feb 2018 04:10:06 +0000</pubDate>
      
      <guid>/blog/html/2018/08/10/introducing_velociraptor.html</guid>
      <description>Hunting and responding like a raptor! At Velocidex we have been running open source endpoint monitoring tools for our clients in order to detect and respond to incidents. One of our favorite tools is GRR, developed by Google internally and then released as open source. GRR is a very powerful tool, with a polished UI and good documentation.
Unfortunately the open source version released by Google suffers from some shortcomings and so we have decided to develop a new project, built on the shoulders of giants called Velociraptor.</description>
    </item>
    
  </channel>
</rss>
